#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	// Brake motors. Set to false to float motors.
	bFloatDuringInactiveMotorPWM = false;

	// Enabled closed loop motor speed calculation. Set to mtrNoReg for open loop.
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;

	// TODO: Update this value bassed on battery level.
	// The max speed used when motor power == 100%. The default value for an open looped system is 1000.
	// On a closed loop system, the calculation needs the maximum speed the motor can do on a low battery, which is around 750.
	nMaxRegulatedSpeed12V = 750;
	return;
}

float toPercent(float val, float max) {
	return val/max;
}

const float maxPower = 100;
const float joyStickSize = 256;
const float joyStickDeadzone = 8;

void drive(float joyY1, float joyX2, float joyY2) {

	// Set joysticks to 0 if under deadzone.
	if (abs(joyY1) < joyStickDeadzone) { joyY1 = 0; }
	if (abs(joyX2) < joyStickDeadzone) { joyX2 = 0; }
	if (abs(joyY2) < joyStickDeadzone) { joyY2 = 0; }

	// Calculate power and direction.
	float power = maxPower * (joyY1 / (joyStickSize / 2));

	// Convert joystick xy to radians on a polar plane.
	float directionRad = atan2(joyY2 , joyX2);

	// Convert direction to degrees and set 0 to forward, -90 left, 90 right.
	float direction = 0;
	if (joyX2 != 0 && joyY2 == 0) {
		direction = 90;
	}
	if (directionRad != 0) {
		direction = ((directionRad * (180/PI)) - 90) * -1;
	}

	// If the directional joystick is facing downward, compensate.
	if (direction > 90) {
		direction = direction - 180;
	}

	float motorLeftPower = 0;
	float motorRightPower = 0;

	if (direction == 0) {
		motorLeftPower = power;
		motorRightPower = power;
	}
	if (direction > 45) {
		motorLeftPower = power;
		motorRightPower = power * toPercent(-direction + 45, 45);
	}
	else  {
		if (direction > 0) {
			motorRightPower = power - power * toPercent(direction, 45);
			motorLeftPower = power;
		}
		else  {
			if (direction < -45) {
				motorLeftPower = power * toPercent(-direction - 45, 45) * -1;
				motorRightPower = power;
				} else {
				if (direction < 0) {
					motorLeftPower = power + power * toPercent(direction, 45);
					motorRightPower = power;
				}
			}
		}
	}

	motor[motorLeft] = (int) motorLeftPower;
	motor[motorRight] = (int) motorRightPower;
}

void servos()
{
	bool dpadDown = (joystick.joy1_TopHat == 4);
	bool dpadUp = (joystick.joy1_TopHat == 0);

	if (dpadDown)
	{
		servo[servo1] = 0;
	}
	else if (dpadUp)
	{
		servo[servo1] = 256;
	}
	else {
		servo[servo1] = 128;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	// Wait for start of tele-op phase
	waitForStart();

	while (true)
	{
		getJoystickSettings(joystick);
		drive(joystick.joy1_y1 * -1, joystick.joy1_x2, joystick.joy1_y2 * 0;
		servos();
	}
}
